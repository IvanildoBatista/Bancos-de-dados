--  SELECIONA TODOS OS REGISTROS DA TABELA ORDERS

SELECT *
FROM ORDERS;

-- SELECIONA TODOS OS REGISTROS DA TABELA ORDERS EXIBINDO APENAS AS COLUNAS ORDER_ID E ORDER_STATUS

SELECT  ORDER_ID
       ,ORDER_STATUS
FROM ORDERS;

-- SELECIONA TODOS OS REGISTROS DA TABELA ORDERS EXIBINDO APENAS AS COLUNAS ORDER_ID, ORDER_STATUS E CUSTOMER_ID

SELECT  ORDER_ID
       ,ORDER_STATUS
       ,CUSTOMER_ID
FROM ORDERS;

-- TRABALHANDO COM ALIAS

SELECT  ORDER_ID AS 'ID_PEDIDO'
       ,ORDER_STATUS AS 'STATUS_PEDIDO'
       ,CUSTOMER_ID AS 'ID_DO_CLIENTE'
FROM ORDERS;


-- SELECIONANDO APENAS LINHAS ÚNICAS

SELECT  DISTINCT ORDER_ID AS 'ID_PEDIDO'
       ,ORDER_STATUS AS 'STATUS_PEDIDO'
       ,CUSTOMER_ID AS 'ID_DO_CLIENTE'
FROM ORDERS;


-- CONTANDO A QUANTIDADE DE REGISTROS RETORNADOS PELA CONSULTA

SELECT COUNT(*)
FROM ORDERS;

-- DANDO UM APELIDO AO RESULTADO RETORNADO

SELECT COUNT(*) AS 'Quantidade de linhas'
FROM ORDERS;

-- CONTANDO A QUANTIDADE DE LINHAS NÃO NULAS DA COLUNA CUSTOMER_ID E DANDO UM APELIDO AO RESULTADO RETORNADO

SELECT COUNT(CUSTOMER_ID) AS 'Quantidade de clientes'
FROM ORDERS;

-- TRABALHANDO COM A OPÇÃO WHERE

SELECT *
FROM ORDERS
WHERE ORDER_STATUS='delivered'


-- CONTANDO TODOS OS REGISTROS COM O STATUS 'delivered'

SELECT COUNT(*)
FROM ORDERS
WHERE ORDER_STATUS='delivered'


-- CONTANDO TODOS OS REGISTROS COM O STATUS DIFERENTE DE 'delivered'

SELECT COUNT(*)
FROM ORDERS
WHERE ORDER_STATUS != 'delivered'

-- SELECIONA TODAS AS LINHAS DA TABELA ORDERS COM O STATUS diferentes de 'delivered' e que não tenha pedidos aprovados

SELECT *
FROM ORDERS
WHERE ORDER_STATUS != 'delivered'
AND ORDER_APPROVED_AT IS NULL

-- SELECIONA TODAS AS LINHAS DA TABELA ORDERS COM O STATUS DIFERENTES de 'delivered' OU QUE NÃO TENHAM PEDIDOS APROVADOS

SELECT *
FROM ORDERS
WHERE ORDER_STATUS !='delivered'
OR ORDER_APPROVED_AT IS NULL

-- CONSULTA TODOS OS CLIENTES CUJA A CIDADE COMEÇA COM MOGI

SELECT * 
FROM CUSTOMERS
WHERE CUSTOMER_CITY LIKE 'mogi%'

-- CONSULTA TODOS OS CLIENTES CUJA A CIDADE NÃO COMEÇA COM MOGI

SELECT * 
FROM CUSTOMERS
WHERE CUSTOMER_CITY NOT LIKE 'mogi%'

-- CONTA A QUANTIDADE DE LINHAS AGRUPANDO OS RESULTADOS PELO ID DO CLIENTE

SELECT COUNT(*)
FROM ORDERS
GROUP BY CUSTOMER_ID

-- SOMA A QUANTIDADE DE VALOR GASTO POR TIPO DE PAGAMENTO.

SELECT PAYMENT_TYPE
      ,SUM(PAYMENT_VALUE)
FROM ORDER_PAYMENTS
GROUP BY PAYMENT_TYPE

-- CALCULA O VALOR MÉDIO GASTO POR TIPO TE PAGAMENTO

SELECT PAYMENT_TYPE
      ,AVG(PAYMENT_VALUE)
FROM ORDER_PAYMENTS
GROUP BY PAYMENT_TYPE

-- CALCULA O VALOR MÍNIMO GASTO POR TIPO DE PAGAMENTO

SELECT PAYMENT_TYPE
      ,MIN(PAYMENT_VALUE)
FROM ORDER_PAYMENTS
GROUP BY PAYMENT_TYPE

-- CALCULA O VALOR MÁXIMO GASTO POR TIPO DE PAGAMENTO

SELECT PAYMENT_TYPE
      ,MAX(PAYMENT_VALUE)
FROM ORDER_PAYMENTS
GROUP BY PAYMENT_TYPE

-- USANDO A CLAUSULA HAVING

SELECT PAYMENT_TYPE
      ,SUM(PAYMENT_VALUE)
FROM ORDER_PAYMENTS
GROUP BY PAYMENT_TYPE
HAVING PAYMENT_TYPE IS NOT NULL

-- FILTRANDO O RESULTADO COM A CLÁUSULA WHERE

SELECT PAYMENT_TYPE
      ,SUM(PAYMENT_VALUE)
FROM ORDER_PAYMENTS
GROUP BY PAYMENT_TYPE
WHERE SUM(PAYMENT_VALUE) > 0

-- USANDO A CLÁUSULA HAVING PARA FILTRAR APENAS GRUPOS COM VALORES MAIOR QUE 0

SELECT PAYMENT_TYPE
      ,SUM(PAYMENT_VALUE)
FROM ORDER_PAYMENTS
GROUP BY PAYMENT_TYPE
HAVING SUM(PAYMENT_VALUE) > 0


--  USANDO A CLÁUSULA ORDER BY PARA ORDENAÇÃO POR ORDEM ALFABÉTICA

SELECT CUSTOMER_ID
      ,CUSTOMER_CITY
      ,CUSTOMER_STATE
FROM CUSTOMERS
ORDER BY CUSTOMER_CITY

--  USANDO A CLÁUSULA ORDER BY PARA ORDENAÇÃO POR ORDEM DESCRECENTE

SELECT CUSTOMER_ID
      ,CUSTOMER_CITY
      ,CUSTOMER_STATE
FROM CUSTOMERS
ORDER BY CUSTOMER_CITY DESC

-- COMBINANDO AS CLÁUSULAS GROUP BY E ORDER BY

SELECT CUSTOMER_STATE
      ,COUNT(*) as 'Quantidade'
FROM CUSTOMERS
GROUP BY CUSTOMER_STATE
ORDER BY 2 DESC;


-- TRABALHANDO COM JUNÇÕES - ENTENDENDO INNER JOINS
-- SELECIONA OS PEDIDOS, STATUS, O ID DO CLIENTE, A CIDADE E O ESTADO A PARTIR DAS TABELAS ORDERS E CUSTOMERS.

SELECT ORDER_ID
      ,PEDIDO.ORDER_STATUS
      ,CLIENTE.CUSTOMER_ID
      ,CLIENTE.CUSTOMER_CITY
      ,CLIENTE.CUSTOMER_STATE
FROM ORDERS PEDIDO INNER JOIN CUSTOMERS CLIENTE
ON PEDIDO.CUSTOMER_ID = CLIENTE.CUSTOMER_ID


-- UNINDO UMA TERCEIRA TABELA
SELECT ORDER_ID
      ,PEDIDO.ORDER_STATUS
      ,CLIENTE.CUSTOMER_ID
      ,CLIENTE.CUSTOMER_CITY
      ,CLIENTE.CUSTOMER_STATE
      --,ITEN.PRICE
FROM ORDERS PEDIDO INNER JOIN CUSTOMERS CLIENTE
ON PEDIDO.CUSTOMER_ID = CLIENTE.CUSTOMER_ID
AND INNER JOIN ORDER_PAYMENTS ITEN
ON ITEN.ORDER_ID = PEDIDO.ORDER_ID


-- SELECIONANDO DADOS DAS TABELAS DE PEDIDOS, PAGAMENTOS E ITENS

SELECT PEDIDOS.ORDER_ID AS ID_PEDIDO
      ,PRODUTOS.PRODUCT_ID AS ID_PRODUTO
      ,PRODUTOS.PRODUCT_CATEGORY_NAME AS CATEGORIA_PRODUTO
      ,PRODUTOS.PRODUCT_PHOTOS_QTY AS QTD_FOTOS_PRODUTO
      ,ITENS.PRICE AS PREÇO
      ,PAGAMENTOS.PAYMENT_TYPE AS TIPO_PAGAMENTO
      ,PAGAMENTOS.PAYMENT_VALUE AS VALOR_PAGAMENTO
FROM ORDER_ITEMS ITENS INNER JOIN PRODUCTS PRODUTOS
ON ITENS.PRODUCT_ID = PRODUTOS.PRODUCT_ID

INNER JOIN ORDERS PEDIDOS
ON PEDIDOS.ORDER_ID = ITENS.ORDER_ID

INNER JOIN ORDER_PAYMENTS PAGAMENTOS
ON PAGAMENTOS.ORDER_ID = PEDIDOS.ORDER_ID

WHERE PRODUTOS.PRODUCT_PHOTOS_QTY > 1


-- LIMITANDO A QUANTIDADE DE LINHAS RETORNADAS

-- SELECIONANDO DADOS DAS TABELAS DE PEDIDOS, PAGAMENTOS E ITENS

SELECT PEDIDOS.ORDER_ID AS ID_PEDIDO
      ,PRODUTOS.PRODUCT_ID AS ID_PRODUTO
      ,PRODUTOS.PRODUCT_CATEGORY_NAME AS CATEGORIA_PRODUTO
      ,PRODUTOS.PRODUCT_PHOTOS_QTY AS QTD_FOTOS_PRODUTO
      ,ITENS.PRICE AS PREÇO
      ,PAGAMENTOS.PAYMENT_TYPE AS TIPO_PAGAMENTO
      ,PAGAMENTOS.PAYMENT_VALUE AS VALOR_PAGAMENTO
FROM ORDER_ITEMS ITENS INNER JOIN PRODUCTS PRODUTOS
ON ITENS.PRODUCT_ID = PRODUTOS.PRODUCT_ID

INNER JOIN ORDERS PEDIDOS
ON PEDIDOS.ORDER_ID = ITENS.ORDER_ID

INNER JOIN ORDER_PAYMENTS PAGAMENTOS
ON PAGAMENTOS.ORDER_ID = PEDIDOS.ORDER_ID

WHERE PRODUTOS.PRODUCT_PHOTOS_QTY > 1

LIMIT 100










-- USANDO FUNÇÕES ÚTEIS DO SGBD:
-- FUNÇÃO RANDOM()
SELECT RANDOM() AS Random;

-- FUNÇÃO UPPER

SELECT UPPER(PRODUCT_CATEGORY_NAME) FROM PRODUCTS;

-- FUNÇÃO LOWER

SELECT LOWER(PRODUCT_CATEGORY_NAME) FROM PRODUCTS;

-- FUNÇÃO LENGTH

SELECT LENGTH(PRODUCT_CATEGORY_NAME) FROM PRODUCTS;

-- FUNÇÃO PRAGMA

PRAGMA TABLE_INFO(ORDER_ITEMS);

-- FUNCAO CAST
-- ENTENDENDO A APLICABILIDADE DA FUNÇÃO CAST
SELECT PRICE
FROM ORDER_ITEMS
WHERE PRICE > 100

-- CONVERTENDO O VALOR DA COLUNA PRICE

SELECT CAST(PRICE AS INT) AS PRICE
FROM ORDER_ITEMS
WHERE CAST(PRICE AS INT) > 100

-- SELECIONANDO DADOS DAS TABELAS DE PEDIDOS, PAGAMENTOS E ITENS

SELECT PEDIDOS.ORDER_ID
      ,PRODUTOS.PRODUCT_ID
      ,PRODUTOS.PRODUCT_CATEGORY_NAME
      ,PRODUTOS.PRODUCT_PHOTOS_QTY
      ,ITENS.PRICE
      ,PAGAMENTOS.PAYMENT_TYPE
      ,PAGAMENTOS.PAYMENT_VALUE
FROM ORDER_ITEMS ITENS INNER JOIN PRODUCTS PRODUTOS
ON ITENS.PRODUCT_ID = PRODUTOS.PRODUCT_ID

INNER JOIN ORDERS PEDIDOS
ON PEDIDOS.ORDER_ID = ITENS.ORDER_ID

INNER JOIN ORDER_PAYMENTS PAGAMENTOS
ON PAGAMENTOS.ORDER_ID = PEDIDOS.ORDER_ID

WHERE CAST(ITENS.PRICE AS INT) > 100.00


-- LEFT JOIN
-- SELECIONA OS PEDIDOS SE HOUVER PEDIDOS NA TABELA PEDIDOS MAS NÃO NECESSÁRIAMENTE NA TABELA CLIENTES.

SELECT ORDER_ID
      ,PEDIDO.ORDER_STATUS
      ,CLIENTE.CUSTOMER_ID
      ,CLIENTE.CUSTOMER_CITY
      ,CLIENTE.CUSTOMER_STATE
FROM ORDERS PEDIDO LEFT JOIN CUSTOMERS CLIENTE
ON PEDIDO.CUSTOMER_ID = CLIENTE.CUSTOMER_ID


-- RIGHT JOIN
-- SELECIONA OS PEDIDOS SE HOUVER REGISTROS NA TABELA CLIENTES MAS NÃO NECESSÁRIAMENTE NA TABELA PEDIDOS.

SELECT ORDER_ID
      ,PEDIDO.ORDER_STATUS
      ,CLIENTE.CUSTOMER_ID
      ,CLIENTE.CUSTOMER_CITY
      ,CLIENTE.CUSTOMER_STATE
FROM ORDERS PEDIDO RIGHT JOIN CUSTOMERS CLIENTE


-- SUBQUERIES
-- CONSULTA TODOS OS PRODUTOS DA TABELA PRODUTOS ONDE O PREÇO DOS ITEMS FOR MAIOR QUE 500.

SELECT *
FROM PRODUCTS
     WHERE PRODUCT_ID = ( SELECT PRODUCT_ID
                           FROM ORDER_ITEMS
                           WHERE CAST(PRICE AS INT) > 500)

-- USANDO O OPERADOR IN
SELECT *
FROM PRODUCTS
     WHERE PRODUCT_ID IN ( SELECT PRODUCT_ID
                           FROM ORDER_ITEMS
                           WHERE CAST(PRICE AS INT) > 500)

-- UM POUCO DE DDL

CREATE TABLE funcionarios(
   ID INT PRIMARY KEY     NOT NULL,
   NOME           TEXT    NOT NULL,
   IDADE          INT     NOT NULL,
   SEXO           CHAR(1),
   SALARIO         REAL
);

-- CONSULTANDO A TABELA PREVIAMENTE CRIADA
SELECT *
FROM FUNCIONARIOS

-- RENOMEANDO UMA TABELA
ALTER TABLE FUNCIONARIOS RENAME TO COLABORADORES;

-- ADICIONANDO UMA NOVA COLUNA NA TABELA COLABORADORES

ALTER TABLE COLABORADORES 
ADD COLUMN ENDERECO TEXT

-- CONSULTA A TABELA
SELECT *
FROM COLABORADORES

-- APAGANDO UMA TABELA CRIADA
DROP TABLE COLABORADORES







-- TRABALHANDO COM INSTRUÇÕES DE DML
-- INSTRUÇÃO INSERT
-- SINTAXE
INSERT INTO TABLE_NAME [(column1, column2, column3,...columnN)]  
VALUES (value1, value2, value3,...valueN);

-- EXEMPLO DE INSERÇÃO DE LINHAS COM TODAS AS COLUNAS
INSERT INTO TABLE_NAME VALUES (value1,value2,value3,...valueN);

-- EXEMPLO DE INSERT NA TABELA FUNCIONARIOS
INSERT INTO FUNCIONARIOS (ID, NOME, IDADE, SEXO, SALARIO)
VALUES (1, 'José', 32, 'M', 2000);

-- INSERINDO MAIS FUNCIONÁRIOS
INSERT INTO FUNCIONARIOS (ID, NOME, IDADE, SEXO, SALARIO)
VALUES (1, 'José', 32, 'M', 2000);

INSERT INTO FUNCIONARIOS (ID, NOME, IDADE, SEXO, SALARIO)
VALUES (2, 'Maria', 35, 'F', 3000);

INSERT INTO FUNCIONARIOS (ID, NOME, IDADE, SEXO, SALARIO)
VALUES (3, 'Norma', 55, 'F', 5000);

-- CONSULTANDO A TABELA FUNCIONÁRIOS
SELECT * FROM FUNCIONARIOS






-- A INSTRUÇÃO UPDATE
-- USADA PARA ATUALIZAR DADOS EM UMA TABELA

UPDATE table_name
SET column1 = value1, column2 = value2...., columnN = valueN
WHERE [condition];

-- ATUALIZA A IDADE DO FUNCIONÁRIO CUJO O ID = 3
UPDATE FUNCIONARIOS SET IDADE = 57 WHERE ID = 3;

-- CONSULTA DA TABELA FUNCIONÁRIOS
SELECT * FROM FUNCIONARIOS

-- ATUALIZA O SALARIO DOS FUNCIONÁRIOS CUJO O ID É MAIOR QUE 1 (VERIFIQUE A QUANTIDADE DE LINHAS AFETADAS)
UPDATE FUNCIONARIOS SET SALARIO = 6000 WHERE ID > 1;

-- CONSULTA DA TABELA FUNCIONÁRIOS
SELECT * FROM FUNCIONARIOS

-- A INSTRUÇÃO UPDATE EXECUTADA SEM A CLÁUSULA WHERE IRÁ ATUALIAR TODA A TABELA. (ATENÇÃO)
UPDATE FUNCIONARIOS SET SALARIO = 6000

-- CONSULTA DA TABELA FUNCIONÁRIOS
SELECT * FROM FUNCIONARIOS





-- INSTRUÇÃO DELETE
-- USADA PARA DELETAR DADOS DE UMA TABELA.

DELETE FROM table_name
WHERE [condition];

SELECT * FROM FUNCIONARIOS

-- UTILIZA A CLÁUSULA WHERE
-- APAGA LINHAS DA TABELA FUNCIONARIOS NOS QUAIS O ID É IGUAL A 3
DELETE FROM FUNCIONARIOS WHERE ID = 3;

-- APAGA TODAS AS LINHAS DA TABELA FUNCIONÁRIOS
DELETE FROM FUNCIONARIOS;


-- COMBINANDO DML E SQL

DELETE FROM FUNCIONARIOS WHERE ID IN (SELECT ID
                                      FROM FUNCIONARIOS
                                      WHERE ID > 2)
-- CONSULTA A TABELA FUNCIONARIOS                 
SELECT * FROM FUNCIONARIOS

-- INSERE A LINHA NOVAMENTE NA TABELA FUNCIONARIOS
INSERT INTO FUNCIONARIOS (ID, NOME, IDADE, SEXO, SALARIO)
VALUES (3, 'Norma', 55, 'F', 5000);

-- ATUALIZA A LINHA ID BASEADO NA QUERY
UPDATE FUNCIONARIOS SET IDADE = 57
WHERE ID IN (SELECT ID
             FROM FUNCIONARIOS
             WHERE ID > 2)